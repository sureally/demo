---
layout: article
title: 回溯问题
date: 2020/6/26 12:28
categories:
tags:
root-path: ../..
----------------

# 解决一个回溯问题，实际上就是一个决策树的遍历过程。你只需要思考 3 个问题：

1. 路径：也就是已经做出的选择。
2. 选择列表：也就是你当前可以做的选择。
3. 结束条件：也就是到达决策树底层，无法再做选择的条件。

# 回溯框架

```java
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return

    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择
```

**其核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」**

# 特点

必须说明的是，不管怎么优化，都符合回溯框架，而且时间复杂度都不可能低于 O(N!)，因为穷举整棵决策树是无法避免的。  
这也是回溯算法的一个特点，不像动态规划存在重叠子问题可以优化，回溯算法就是纯暴力穷举，复杂度一般都很高

# 排列/组合/子集问题

以上，就是排列组合和子集三个问题的解法，总结一下：

## 子集问题
- 利用数学归纳思想，假设已知一个规模较小的问题的结果，思考如何推导出原问题的结果。
- 回溯算法，**要用 start 参数排除已选择的数字**。

## 组合问题
回溯思想，结果可以表示成树结构，我们只要套用回溯算法模板即可，**关键点在于要用一个 start 排除已经选择过的数字**。

##  排列问题

回溯思想，也可以表示成树结构套用算法模板，关键点在于使用 contains 方法排除已经选择的数字，前文有详细分析，这里主要是和组合问题作对比。
